// 2.7
// Создать квадратную матрицу размера MxM, где M является целым числом из диапазона [2, 5]. Конкретный размер матрицы задается пользователем.
// Матрица содержит только целые числа из диапазона [1, 100], которые могут быть как случайными, так и вводиться пользователем.
// Отсортировать по убыванию элементы, принадлежащие или лежащие ниже главной диагонали матрицы, остальные элементы умножить на минус один.
// Результаты обработки матрицы вывести на экран.

#include <iostream> // Подключение библиотеки iostream
#include <string> // Подключение библиотеки string
#include <windows.h> // Подключение библиотеки windows.h
#include <cstdlib> // Подключение библиотеки cstdlib
using namespace std; // Объявление пространства имём std
int length_of_matrix() { // Объявление функции length_of_matrix
	string m; // Создание переменной m
	while (true) { // Запуск цикла, который будет работать до тех пор, пока пользователь не введет целое число из диапазона [2, 5]
		cout << "Введите целое значение M (количество строк и столбцов матрицы) в диапазоне [2, 5]\n"; // Вывод предложения в кавычках на экран
		cout.width(8); // Размер следующего выводимого сообщения (8 символов)
		cout << "Ввод: "; // Вывод слова в кавычках на экран, засчёт предыдущей команды перед словом будет отступ в 2 символа
		cin >> m; // Получение переменной m от пользователя
		if (m == "2" || m == "3" || m == "4" || m == "5") // Если переменная m равна одному из значений (2, 3, 4 или 5), то программа идёт по этому пути
			break; // Завершение работы цикла
		else { // Иначе
			cout << "Допущена ошибка! Вы должны вводить только целые числа из диапазона [2, 5]! Повторите попытку ввода!\n"; // Вывод предложения в кавычках на экран
			m.clear(); // Очищение значения переменной m
		}
	}
	return stoi(m); // Возвращение целочисленного значения длины стороны квадратной матрицы
}
string answer_to_question() { // Объявление функции answer_of_question
	string answer; // Создание переменной answer
	while (true) { // Запуск цикла, который будет работать до тех пор, пока пользователь не ответит на вопрос корректно
		cout << "Вы хотите ввести данные в матрицу самостоятельно? (1/0)\n"; // Вывод предложения в кавычках на экран
		cout.width(8); // Размер следующего выводимого сообщения (8 символов)
		cout << "Ввод: "; // Вывод слова в кавычках на экран, засчёт предыдущей команды перед словом будет отступ в 2 символа
		cin >> answer; // Получение переменной answer от пользователя
		if (answer == "1" || answer == "0") // Если переменная answer равна одному из значений (0 или 1), то программа идёт по этому пути
			break; // Завершение работы цикла
		else { // Иначе
			cout << "Допущена ошибка! Вы должны ответить на вопрос только одним символом (1/0)! Повторите попытку ввода!\n"; // Вывод предложения в кавычках на экран
			answer.clear(); // Очищение значения переменной answer
		}
	}
	return answer; // Возвращение ответа на вопрос
}
int matrix_from_user(int *matrix, int M) { // Объявление функции matrix_from_user
	cout << "Далее Вам требуется вводить значения элементов в диапазоне [1, 100] (к примеру: A[1][0] = 5)\n"; // Вывод предложения в кавычках на экран
	for (int i = 0; i < M; i++) { // Цикл for для строк матрицы с шагом 1
		for (int j = 0; j < M; j++) { // Цикл for для столбцов матрицы с шагом 1
			string X; // Создание переменной X, в которую программа будет записывать полученный результат от пользователя
			bool f = false; // Создание переменной f, которая будет отвечать за работу цикла, и присваивание ей значения false
			while (!f) { // Пока значение f равно false, будет работать цикл
				cout.width(5); // Размер следующего выводимого сообщения (5 символов)
				cout << "A[" << i << "][" << j << "] = "; // Вывод символов в кавычках на экран и индексов элемента матрицы, засчёт предыдущей команды перед буквой A будет отступ в 3 символа
				cin >> X; // Получение переменной X от пользователя
				int l = X.length(); // Создание переменной l и присваивание ей длины строки X
				bool p = true; // Создание переменной p, которая будет отвечать за тип вводимого значения (целое число или нет), и присваивание ей значения true (подразумевается, что пользователь ввёл целое число)
				for (int k = 0; k < l; k++) { // Цикл for для всех сиволов строки X с шагом 1
					/*if (X[0] == '0') {
						cout << "Допущена ошибка! Вы должны вводить только целые числа из диапазона [1, 100]! Повторите попытку ввода!\n"; // Вывод предложения в кавычках на экран
						X.clear(); // Очищение значения переменной X
						p = false; // Присваивание переменной p значения false
						break; // Завершение работы цикла
					}*/
					if (!isdigit(X[k])) { // Проверка на то, является ли элемент строки не цифрой
						cout << "Допущена ошибка! Вы должны вводить только целые числа из диапазона [1, 100]! Повторите попытку ввода!\n"; // Вывод предложения в кавычках на экран
						X.clear(); // Очищение значения переменной X
						p = false; // Присваивание переменной p значения false
						break; // Завершение работы цикла
					}
				}
				if (p) { // Если переменная p не изменилась, то будет работать код ниже
					int x = stoi(X); // Создание переменной x и присваивание ей целочисленного значения X с помощью функции перевода строки в челое число
					if (x >= 1 && x <= 100) { // Если число находится в диапазоне [1, 100], то программа пойдет по этому пути
						*(matrix + i * M + j) = x; // Присваивание элементу матрицы значения x
						f = true; // Присваивание переменной f значения true
					}
					else { // Иначе
						cout << "Допущена ошибка! Вы должны вводить только целые числа из диапазона [1, 100]! Повторите попытку ввода!\n"; // Вывод предложения в кавычках на экран
						X.clear(); // Очищение значения переменной X
					}
				}
			}
		}
	}
	return *matrix; // Возвращение matrix
}
int matrix_from_random(int* matrix, int M) { // Объявление функции matrix_from_random
	srand(time(0)); // Команда, отвечающая за случайную генерацию чисел при каждом запуске программы
	cout << "Массив будет заполнен случайными целыми числами в диапазоне [1, 100].\n"; // Вывод предложения в кавычках на экран
	for (int i = 0; i < M; i++) { // Цикл for для строк матрицы с шагом 1
		for (int j = 0; j < M; j++) // Цикл for для столюцов матрицы с шагом 1
			*(matrix + i * M + j) = rand() % 100 + 1; // Генерация случайных чисел для элементов матрицы из диапазона [1, 100]
	}
	return *matrix; // Возвращение matrix
}
void cout_matrix(int* matrix, int M) { // Объявление функции cout_matrix
	for (int i = 0; i < M; i++) { // Цикл for для строк матрицы с шагом 1
		for (int j = 0; j < M; j++) { // Цикл for для столбцов матрицы с шагом 1
			cout.width(5); // Размер следующего выводимого сообщения (5 символов)
			cout << *(matrix + i * M + j); // Вывод на экран элемента матрицы
		}
		cout << endl; // Переход на новую строку
	}
}
int matrix_sort(int* matrix, int M) { // Объявление функции matrix_sort
	int k1 = ((M * M) - M) / 2 + M; // Создание переменной k1, которая является количеством элементов, лежащих на главной диагонали и под ней
	int* m1 = new int[k1]; // Создание одномерно массива m1 и выделение места для него
	int k2 = (M * M) - k1; // Создание переменной k2, которая является количеством элементов, лежащих над главной диагональю
	int* m2 = new int[k2]; // Создание одномерно массива m2 и выделение места для него
	k1 = 0; // Обнуление k1
	k2 = 0; // Обнуление k2
	for (int i = 0; i < M; i++) { // Цикл for для строк матрицы с шагом 1
		for (int j = 0; j < M; j++) { // Цикл for для столбцов матрицы с шагом 1
			if (i >= j) { // Если элемент лежит на главной диагонали или под ней, то программа пойдет по этому пути
				m1[k1] = *(matrix + i * M + j); // Присваивание элементу одномерного массива m1 значения элемента матрицы matrix
				k1++; // Увеличение k1 на 1
			}
			else { // Иначе
				m2[k2] = *(matrix + i * M + j); // Присваивание элементу одномерного массива m2 значения элемента матрицы matrix
				k2++;  // Увеличение k2 на 1
			}
		}
	}
	int swap; // Создание переменной swap, которая будет отвечать за промежуточное значение для обмена значениями при сортировке
	for (int i = 0; i < k1; i++) { // Цикл for для первого элемента сравнения
        for (int j = i + 1; j < k1 + 1; j++) { // Цикл for для второго элемента сравнения
            if (m1[i] < m1[j]) { // Если первый элемент меньше второго, то они меняются местами
                swap = m1[j]; // Присваивание переменной swap значения переменной m1[j]
                m1[j] = m1[i]; // Присваивание переменной m1[j] значения переменной m1[i]
                m1[i] = swap; // Присваивание переменной m1[i] значения переменной swap
            }
        }
    }
    k1 = 1; // Присваивание k1 значения 1
	k2 = 0; // Присваивание k2 значения 0
	for (int i = 0; i < M; i++) { // Цикл for для строк матрицы с шагом 1
		for (int j = 0; j < M; j++) { // Цикл for для столбцов матрицы с шагом 1
			if (i >= j) { // Если элемент лежит на главной диагонали или под ней, то программа пойдет по этому пути
				*(matrix + i * M + j) = m1[k1]; // Присваивание элементу матрицы matrix значения элемента отсортированного одномерного массива m1
				k1++; // Увеличение k1 на 1
			}
			else { // Иначе
				*(matrix + i * M + j) = -m2[k2]; // Присваивание элементу матрицы matrix значения элемента одномерного массива m2, умноженного на -1
				k2++; // Увеличение k2 на 1
			}
		}
	}
	delete[] m1; // Удаление одномерного массива m1
	delete[] m2; // Удаление одномерного массива m2
	return *matrix; // Возвращение matrix
}
int main() // Объявление функции main
{
	SetConsoleCP(CP_UTF8); // Разрешение на использование русских символов в консоли
	SetConsoleOutputCP(CP_UTF8); // Разрешение на использование русских символов в консоли
	int M = length_of_matrix(); // Создание переменной M, в которой будет храниться размер матрицы
	string answer = answer_to_question(); // Создание переменной answer, в которую программа будет записывать полученный результат от пользователя
	int* matrix = new int[M * M]; // Создание переменной matrix, которая является целочисленной квадратной матрицы, и выделение места для неё
	if (answer == "1") // Если переменная answer равна 1, то программа пойдёт по этому пути
		*matrix = matrix_from_user(matrix, M); // Матрица заполняется пользователем
	else // Иначе
		*matrix = matrix_from_random(matrix, M); // Матрица заполняется случайными числами
	cout << "Полученная матрица:\n"; // Вывод предложения в кавычках на экран
	cout_matrix(matrix, M); // Вывод матрицы на экран
	*matrix = matrix_sort(matrix, M); // Сортировка матрицы по условию
	cout << "Итоговая матрица:\n"; // Вывод предложения в кавычках на экран
	cout_matrix(matrix, M); // Вывод матрицы на экран
	delete[] matrix; // Удаление матрицы matrix
	return 0; // Завершение работы программы
}